# Lv9+.3. 优化

在之前的章节中, 你实现的编译器只负责把 SysY 编译到 RISC-V 汇编, 而不会进行任何形式的优化. 实际上, 在业界的各类编译器实现中, 优化相关的部分所占的比重, 要远远大于其他的部分. 毕竟, 生成高性能的程序, 才是编译器的目标.

编译优化并不是一件多么高深莫测的事情. 有很多简单的优化, 你只要稍做了解, 便可以把它们添加到你的编译器中.

## 优化的分类

编译器中涉及的优化, 大体可以分为两类:

* **机器无关优化:** 和目标机器 (目标指令系统) 无关的, 在 IR 层面就能进行的优化. 比如对程序结构的变换, 或者对 IR 中冗余操作的消除.
* **机器相关优化:** 和目标机器 (目标指令系统) 相关的, 在目标代码上进行的优化. 比如软流水 ([software pipelining](https://en.wikipedia.org/wiki/Software_pipelining)), 或者一些目标代码层面的窥孔优化.

接下来我们为这两类优化分别举一个简单的例子.

### 死代码消除

死代码消除 ([dead code elimination](https://en.wikipedia.org/wiki/Dead_code_elimination), DCE), 顾名思义, 就是删除程序里根本用不到的代码, 也就是所谓的 “死代码”. 比如对于如下的 SysY 程序:

```c
int main() {
  int a = 1;
  int b = 2;
  a = a + 3;
  b = b + a;
  return 0;
}
```

你的编译器可能会生成对应的 Koopa IR:

```koopa
fun @main(): i32 {
%entry:
  @a = alloc i32
  store 1, @a
  @b = alloc i32
  store 2, @b
  %0 = load @a
  %1 = add %0, 3
  store %0, @a
  %2 = load @b
  %3 = load @a
  %4 = add %2, %3
  store %4, @b
  ret 0
}
```

你可以发现, SysY 程序里声明了两个变量, 哼哧哼哧一顿算, 最后只是返回了一个 0, 之前的计算结果一个都没用到. 那我们为什么不干脆把这些没用的代码都删掉呢:

```koopa
fun @main(): i32 {
%entry:
  ret 0
}
```

这段程序和之前那段完全等价, 但看起来显然清爽了许多, 效率也更高. 那我们要怎么才能实现 DCE 呢? DCE 本质上是把没用的代码删掉, 那我们必须先知道, 哪些代码是没用的, 或者换句话说: 知道哪些代码是有用的.

从例子出发, 我们知道, 这个例子中只有那句 `return` 是有用的, 因为它控制了 `main` 函数的返回值, 使得我们能在外部观测到这个结果. 而 `return` 语句没有用到之前任何语句的结果, 这些语句就变成了死代码, 因为无论它们存在与否, 我们在外部都观测不到程序执行结果的任何变化.

所以道理就很简单了: 任何会产生副作用的代码都是有用的代码, 任何不产生副作用, 并且执行结果没被有用的代码用到的代码, 都是死代码. 比如:

*  `ret`, `br`, `jump` 都会产生副作用, 即控制流转移. 我们实现的 DCE 暂不关心控制流, 所以所有和控制流相关的代码都可以视作有副作用.
* 如果 `call` 指令调用的函数存在副作用, 那 `call` 指令也会产生副作用. 一个有副作用的函数, 可能执行了 I/O 操作, 可能向指针指向的内存写入了数据 (比如写入了传入的数组参数), 可能写了全局变量, 也可能调用了其他有副作用的函数.
* 如果 `store` 指令写了指针参数, 全局变量, 或者某个被带副作用的语句用到的 `alloc`, 那它也是有副作用的.

?> 关于写指针操作的判断, 其实比上面的描述复杂的多. 当然, 为了避免过于复杂的讨论, 你可以把假设定得更保守一些, 比如假定所有的 `call`/`store` 都是有副作用的. 但这样显然会导致 DCE 的效果大打折扣.
<br><br>
在某些编程语言里, 某个变量的指针/引用可以被到处传来传去, 也可以被任意修改, 导致这些指针/引用又指向了其他的变量. 要想分析某个指针是否指向了可能会导致副作用的那些变量, 你就必须做一些比较复杂的分析. 我们称这类分析为指针分析 ([pointer analysis](https://en.wikipedia.org/wiki/Pointer_analysis)). 这又是编译/程序分析领域的一大深坑.

然后, 你可以从这些已经确定不会被删掉的指令出发, 遍历它们用到的其他指令, 把这些指令也标记为 “有用”. 接着再依次标记和这些指令相关的其他指令……直到再也标记不出新指令为止. 此时, 函数中剩下的指令, 就都可以被删掉了.

?> 如果只是单独实现 DCE, 优化效果还是比较有限的, 毕竟一般我们不会刻意去写一些能被编译器一眼鉴定为死代码的代码.
<br><br>
DCE 存在的价值是为其他优化擦屁股: 很多情况下, 某些优化跑完之后, 会产生一些新的死代码. 比如你实现了常量传播优化, 传播完了之后原先的变量被替换成了一个常量, 所有计算过程都被求出来了——这部分代码就变成了死代码. 如果在此之后再跑一遍 DCE, 整个 IR 就会变得清爽很多.

### 消除冗余 load

对于如下 Koopa IR:

```koopa
%0 = load @a
%1 = add %0, 1
%2 = mul %1, 2
```

如果你没有实现寄存器分配, 那么你的编译器很可能生成这样的目标代码:

```
  lw  t0, 0(sp)   # %0 = load @a
  sw  t0, 4(sp)
  lw  t0, 4(sp)   # %1 = add %0, 1
  li  t1, 1
  add t0, t0, t1
  sw  t0, 8(sp)
  lw  t0, 8(sp)   # %2 = mul %1, 2
  li  t1, 2
  mul t0, t0, t1
  sw  t0, 12(sp)
```

注意, 这段汇编中出现了很多这样的操作:

```
  sw  t0, 4(sp)
  lw  t0, 4(sp)
```

首先把寄存器 `t0` 中的数据保存到栈上, 然后再把刚刚保存的数据重新读回 `t0`. 前一条保存指令还是有用的, 因为后续指令可能会从栈帧中读出保存的值; 但后一条加载指令可谓是一点用都没有——因为 `t0` 的值已经是我们需要的值了. 所以在遇到这种情况时, 你的编译器完全可以把之后的加载指令删掉:

```
  lw  t0, 0(sp)   # %0 = load @a
  sw  t0, 4(sp)
  li  t1, 1       # %1 = add %0, 1
  add t0, t0, t1
  sw  t0, 8(sp)
  li  t1, 2       # %2 = mul %1, 2
  mul t0, t0, t1
  sw  t0, 12(sp)
```

这样, 程序里就会少做很多冗余的操作.

这种优化十分容易实现: 你只需要扫一遍生成的汇编代码, 只要发现后一条 `lw` 用到了前一条 `sw` 的结果, 并且目的寄存器和 `sw` 的源寄存器一致, 你就可以直接把 `lw` 删掉. 这类只需要扫一遍代码, 只把视线局限在刚刚扫过的一小块范围内, 并优化其中的代码的行为, 叫做窥孔优化 ([peephole optimization](https://en.wikipedia.org/wiki/Peephole_optimization)).

你还可以在此基础上更进一步:

* `lw` 的目的寄存器和 `sw` 的源寄存器不一致也没关系, 你可以用一条 `mv` 伪指令替换 `lw`. 平均来看, `mv` 所花的时间要小于访存的时间, 所以这么做也是划算的.
* `lw` 和 `sw` 之间还隔着其他内容也没关系, 只要这些内容不影响 `lw` 读出的数据即可. 比如中间不能出现其他写入 `sw` 寄存器的指令, `call` 指令, 转移指令或 label, 等等.

当然, 在进行上述窥孔优化的时候, 你最好能在数据结构形式的 RISC-V 指令上扫描, 而不是去处理你生成的汇编代码字符串, 因为显然前者效率更高. 也就是说, 你应该设计一种表示 RISC-V 汇编的数据结构, 然后让你的编译器从 Koopa IR 生成这种数据结构, 对其优化后, 再转换为文本形式输出.

## 优化的组织

你可能会给自己的编译器添加非常多的优化, 但作为一个有品位的程序员, 你肯定不希望这些优化的实现散落在源码的各处, 最后凑出一个堪堪能跑但看起来摇摇欲坠的编译器. 所以, 你应该思考一种组织代码的方式, 来优雅地组织你编译器中的优化.

优化所做的事情并不复杂: 我们把优化抽象成一个黑盒, 它的输入是代表程序的数据结构, 比如 IR 或者目标代码, 输出也是相同类型的数据结构, 只不过相比输入要更优化.

```
        +--------------+
IR -->  | Optimization | --> IR'
        +--------------+
```

基于此, 我们不难想象出应该如何在程序中表示优化: 我们可以把所有的优化都抽象成输入输出都是 IR/目标代码类型的函数. 在面向对象语言中, 我们也可以把优化抽象成一个 visitor, 利用 visitor 模式访问 IR/目标代码所代表的各类对象. 这种用来遍历程序结构并对其作出修改的函数/visitor 对象, 在编译器中一般被称作 pass.

最后, 你可以设置一个数组/列表, 用来存储所有的 pass. 编译器在执行优化的时候, 只需要遍历 pass 列表, 把输入的 IR/目标代码依次在每个 pass 上跑一遍, 用前一个 pass 的输出作为后一个的输入, 最终得到的结果就是优化的结果了.

## 更多的优化

我们挑选了一些可以实现在你的编译器中优化, 供你参考. 这些优化总体按照由易到难的顺序排列. 你可以查阅相关书籍 (龙/虎/鲸/EAC 等) 或者 STFW, 来了解这些优化的相关内容和具体实现.

### 机器无关

* 常量传播.
* 函数内联.
* 控制流化简, 比如合并基本块, 删除不可达基本块, 化简已知分支目标的 `br` 指令等等.
* 循环展开, 比如展平所有常数次的循环, 同时把循环次数未知的循环展开 $n$ 次.
* 循环不变量外提 (LICM).
* 归纳变量化简.

### 机器相关

* 强度削弱, 比如把乘除法替换成代价更小的操作.
* 各类窥孔优化, 比如传播 `mv`, load/store 的结果, 化简控制转移指令和 label 等等.
* 指令调度.
